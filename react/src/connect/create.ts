import { findComponentsInDocument, parseFileKey, parseNodeIds } from './helpers'
import axios, { isAxiosError } from 'axios'
import fs from 'fs'
import * as prettier from 'prettier'
import { FigmaRestApi, getApiUrl } from './figma_rest_api'
import { logger } from '../common/logging'
import { camelCase } from 'lodash'

interface GenerateDocsArgs {
  accessToken: string
  figmaNodeUrl: string
  outFile: string
}

function isBooleanKind(propValue: string) {
  const normalized = propValue.toLowerCase()
  return (
    normalized === 'true' ||
    normalized === 'false' ||
    normalized === 'yes' ||
    normalized === 'no' ||
    normalized === 'on' ||
    normalized === 'off'
  )
}

function normalizePropName(name: string) {
  return name.replace(/#[0-9:]*/g, '')
}

function generateCodePropName(name: string) {
  return camelCase(name.replace(/[^a-zA-Z]/g, ''))
}

function normalizePropValue(name: string) {
  // Convert the string to kebab-case
  return name.replace(/[^a-zA-Z0-9]/g, '-').toLowerCase()
}

function normalizeComponentName(name: string) {
  // Convert the string to PascalCase and ensure first character is not a digit
  return name
    .replace(/[^a-zA-Z0-9]/g, ' ')
    .split(' ')
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join('')
    .replace(/^[0-9]/, '_$&')
}

function generateProps(component: FigmaRestApi.Component) {
  const props: string[] = []
  if (
    !component.componentPropertyDefinitions ||
    Object.keys(component.componentPropertyDefinitions).length === 0
  ) {
    return `{}`
  }

  for (const [propName, propDef] of Object.entries(component.componentPropertyDefinitions)) {
    const codePropName = generateCodePropName(propName)
    const figmaPropName = normalizePropName(propName)
    if (propDef.type === 'BOOLEAN') {
      props.push(`"${codePropName}": figma.boolean('${figmaPropName}')`)
    }
    if (propDef.type === 'TEXT') {
      props.push(`"${codePropName}": figma.string('${figmaPropName}')`)
    }
    if (propDef.type === 'VARIANT') {
      if (propDef.variantOptions?.find((value) => isBooleanKind(value))) {
        props.push(`"${codePropName}": figma.boolean('${figmaPropName}')`)
      } else {
        props.push(
          `"${codePropName}": figma.enum('${figmaPropName}', { \n${propDef.variantOptions
            ?.map((value) => `  "${value}": "${normalizePropValue(value)}"`)
            .join(',\n')}})`,
        )
      }
    }
    if (propDef.type === 'INSTANCE_SWAP') {
      props.push(`"${codePropName}": figma.instance('${figmaPropName}')`)
    }
  }
  return `{
  ${props.join(',\n  ')}
}`
}

export async function createFigmadocFromUrl({
  accessToken,
  figmaNodeUrl,
  outFile,
}: GenerateDocsArgs) {
  const fileKey = parseFileKey(figmaNodeUrl)
  const nodeIds = parseNodeIds([figmaNodeUrl])

  const apiUrl = getApiUrl(figmaNodeUrl ?? '') + `/files/${fileKey}?ids=${nodeIds.join(',')}`

  try {
    logger.info('Fetching component information from Figma...')
    const response = await axios.get(apiUrl, {
      headers: {
        'X-Figma-Token': accessToken,
        'Content-Type': 'application/json',
      },
    })

    if (response.status === 200) {
      logger.info('Parsing response')
      const component = findComponentsInDocument(response.data.document, nodeIds)[0]
      const componentName = normalizeComponentName(component.name)

      logger.info('Generating Code Connect file...')

      const figmadoc = `
import { ${componentName} } from './${componentName}'
import figma from '@figma/code-connect'

/**
 * -- This file was auto-generated by \`figma connect create\` --
 * \`props\` includes a mapping from Figma properties and variants to
 * suggested values. You should update this to match the props of your
 * code component, and update the \`example\` function to return the
 * code example you'd like to see in Figma
*/

figma.connect(${componentName}, "${figmaNodeUrl}", {
  props: ${generateProps(component)},
  example: (props) => <${componentName} />
})
`
      let formatted = await prettier.format(figmadoc, {
        parser: 'typescript',
        semi: false,
      })
      const fileName =
        outFile ?? `${process.env.INIT_CWD ?? process.cwd()}/${componentName}.figma.tsx`
      fs.writeFileSync(fileName, formatted)
      logger.info(`Created ${fileName}`)
    } else {
      logger.error(`Failed to get node information from Figma with status: ${response.status}`)
      logger.debug('Failed to get node information from Figma with Body:', response.data)
    }
  } catch (err) {
    if (isAxiosError(err)) {
      if (err.response) {
        logger.error(
          `Failed to get node data from Figma (${err.code}): ${err.response?.status} ${err.response?.data?.err ?? err.response?.data?.message}`,
        )
      } else {
        logger.error(`Failed to get node data from Figma: ${err.message}`)
      }
      logger.debug(JSON.stringify(err.response?.data))
    } else {
      logger.error(`Failed to create: ${err}`)
    }
    process.exit(1)
  }
}
